# xv6_thread_implementation

xv6上でthreadを実装する．

## 基本設計
スレッドの特徴は，生成元のプロセスとアドレス空間を共有し，スタック領域だけ独自のものを持つことである．

本実装では，既存のfork関数を改良し，新たなプロセスのページテーブル割り当ての処理を改良することでスレッドを実装した．


## threadの実装〜Kernel Side〜

### proc.c

**・clone()**

まず，スレッドの生成を行うカーネル側の関数である `clone()`について説明する．基本構造は，fork関数と同じである．
異なる点はページテーブルの割り当てを行うための関数として，`uvmcopy`を使用するのではなく，自作の関数である`uvmcopy_onlystack`を用いている点である．
```c
```


**・thread_exit()**

スレッド用のexit関数．通常の`exit()`を使用してしまうと，アドレス空間を共有している他のプロセスの領域も解放してしまう．


thread_exit()では，自作の`uvmcopy_excludestack()`を用いたあとに，通常の`exit()`を用いることで，他のスレッドと共有している部分のデータは残したままスレッドの処理を終了する．
```c
```


**・join()**

親スレッドが，子スレッドの処理が終了するまで待機するための関数．引数で子スレッドのpidを取る．
```c
```

### vm.c

**・uvmcopy_onlystack()**

スタック領域以外のページテーブルエントリは親プロセスと同じものを参照し，スタック領域のページテーブルエントリのみ，新たに確保した領域に元々のプロセスのスタック領域をコピーしたものを参照する．
```c
```

**・uvmcopy_excludestack()**

スタック領域以外のページテーブルエントリを新たな物理メモリ領域にマッピングし直す関数．

この処理によって，`exit()`によって領域を解放しても，親スレッドは影響を受けることなく処理を続けることが可能になる．
```c
```




